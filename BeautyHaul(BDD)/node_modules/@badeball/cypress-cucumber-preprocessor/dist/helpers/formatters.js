"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHtmlStream = createHtmlStream;
exports.createJsonFormatter = createJsonFormatter;
exports.createUsageFormatter = createUsageFormatter;
exports.createPrettyFormatter = createPrettyFormatter;
const events_1 = require("events");
const html_formatter_1 = require("@cucumber/html-formatter");
const pretty_formatter_1 = __importDefault(require("@cucumber/pretty-formatter"));
const cucumber_1 = require("@cucumber/cucumber");
const chalk_1 = __importDefault(require("chalk"));
const type_guards_1 = require("./type-guards");
const assertions_1 = require("./assertions");
function createHtmlStream() {
    return new html_formatter_1.CucumberHtmlStream(require.resolve("@cucumber/html-formatter/dist/main.css", {
        paths: [__dirname],
    }), require.resolve("@cucumber/html-formatter/dist/main.js", {
        paths: [__dirname],
    }));
}
function createJsonFormatter(envelopes, log) {
    const eventBroadcaster = new events_1.EventEmitter();
    const eventDataCollector = new cucumber_1.formatterHelpers.EventDataCollector(eventBroadcaster);
    const stepDefinitions = envelopes
        .map((m) => m.stepDefinition)
        .filter(type_guards_1.notNull)
        .map((s) => {
        var _a;
        return {
            id: s.id,
            uri: s.sourceReference.uri,
            line: (_a = s.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line,
        };
    });
    new cucumber_1.JsonFormatter({
        eventBroadcaster,
        eventDataCollector,
        log(chunk) {
            (0, assertions_1.assertIsString)(chunk, "Expected a JSON output of string, but got " + typeof chunk);
            log(chunk);
        },
        supportCodeLibrary: {
            stepDefinitions,
        },
        colorFns: null,
        cwd: null,
        parsedArgvOptions: {},
        snippetBuilder: null,
        stream: null,
        cleanup: null,
    });
    return eventBroadcaster;
}
function createUsageFormatter(envelopes, log) {
    const eventBroadcaster = new events_1.EventEmitter();
    const eventDataCollector = new cucumber_1.formatterHelpers.EventDataCollector(eventBroadcaster);
    const stepDefinitions = envelopes
        .map((m) => m.stepDefinition)
        .filter(type_guards_1.notNull)
        .map((s) => {
        var _a;
        return {
            id: s.id,
            uri: s.sourceReference.uri,
            line: (_a = s.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line,
            unwrappedCode: "",
            expression: {
                source: s.pattern.source,
                constructor: {
                    name: "foo",
                },
            },
        };
    });
    new cucumber_1.UsageFormatter({
        eventBroadcaster,
        eventDataCollector,
        log(chunk) {
            (0, assertions_1.assertIsString)(chunk, "Expected a JSON output of string, but got " + typeof chunk);
            log(chunk);
        },
        supportCodeLibrary: {
            stepDefinitions,
        },
        colorFns: null,
        cwd: null,
        parsedArgvOptions: {},
        snippetBuilder: null,
        stream: null,
        cleanup: null,
    });
    return eventBroadcaster;
}
function createPrettyFormatter(useColors, log) {
    const eventBroadcaster = new events_1.EventEmitter();
    const eventDataCollector = new cucumber_1.formatterHelpers.EventDataCollector(eventBroadcaster);
    const colorFns = useColors
        ? {
            forStatus(status) {
                return {
                    AMBIGUOUS: chalk_1.default.red.bind(chalk_1.default),
                    FAILED: chalk_1.default.red.bind(chalk_1.default),
                    PASSED: chalk_1.default.green.bind(chalk_1.default),
                    PENDING: chalk_1.default.yellow.bind(chalk_1.default),
                    SKIPPED: chalk_1.default.cyan.bind(chalk_1.default),
                    UNDEFINED: chalk_1.default.yellow.bind(chalk_1.default),
                    UNKNOWN: chalk_1.default.yellow.bind(chalk_1.default),
                }[status];
            },
            location: chalk_1.default.gray.bind(chalk_1.default),
            tag: chalk_1.default.cyan.bind(chalk_1.default),
            diffAdded: chalk_1.default.green.bind(chalk_1.default),
            diffRemoved: chalk_1.default.red.bind(chalk_1.default),
            errorMessage: chalk_1.default.red.bind(chalk_1.default),
            errorStack: chalk_1.default.grey.bind(chalk_1.default),
        }
        : {
            forStatus() {
                return (x) => x;
            },
            location: (x) => x,
            tag: (x) => x,
            diffAdded: (x) => x,
            diffRemoved: (x) => x,
            errorMessage: (x) => x,
            errorStack: (x) => x,
        };
    new pretty_formatter_1.default({
        eventBroadcaster,
        eventDataCollector,
        log(chunk) {
            (0, assertions_1.assertIsString)(chunk, "Expected a JSON output of string, but got " + typeof chunk);
            log(chunk);
        },
        supportCodeLibrary: null,
        colorFns,
        cwd: null,
        parsedArgvOptions: {
            colorsEnabled: useColors,
        },
        snippetBuilder: null,
        stream: null,
        cleanup: null,
    });
    return eventBroadcaster;
}
