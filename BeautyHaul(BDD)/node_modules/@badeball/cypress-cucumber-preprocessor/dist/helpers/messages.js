"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTimestamp = createTimestamp;
exports.duration = duration;
exports.durationToNanoseconds = durationToNanoseconds;
exports.removeDuplicatedStepDefinitions = removeDuplicatedStepDefinitions;
function createTimestamp() {
    const now = new Date().getTime();
    const seconds = Math.floor(now / 1000);
    const nanos = (now - seconds * 1000) * 1000000;
    return {
        seconds,
        nanos,
    };
}
function duration(start, end) {
    return {
        seconds: end.seconds - start.seconds,
        nanos: end.nanos - start.nanos,
    };
}
function durationToNanoseconds(duration) {
    return Math.floor(duration.seconds * 1000000000 + duration.nanos);
}
function removeDuplicatedStepDefinitions(envelopes) {
    var _a;
    const seenDefinitions = [];
    const findSeenStepDefinition = (stepDefinition) => seenDefinitions.find((seenDefinition) => {
        var _a, _b;
        return (seenDefinition.uri === stepDefinition.sourceReference.uri &&
            seenDefinition.line === ((_a = stepDefinition.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line) &&
            seenDefinition.column ===
                ((_b = stepDefinition.sourceReference.location) === null || _b === void 0 ? void 0 : _b.column));
    });
    for (let i = 0; i < envelopes.length; i++) {
        const { stepDefinition } = envelopes[i];
        if (stepDefinition &&
            stepDefinition.sourceReference.uri !== "not available") {
            const seenDefinition = findSeenStepDefinition(stepDefinition);
            if (seenDefinition) {
                // Remove this from the stack.
                envelopes.splice(i, 1);
                // Make sure we iterate over the "next".
                i--;
                // Find TestCase's in which this is used.
                for (let x = i; x < envelopes.length; x++) {
                    const { testCase } = envelopes[x];
                    if (testCase) {
                        for (const testStep of testCase.testSteps) {
                            // Replace ID's of spliced definition with ID of the prevously seen definition.
                            testStep.stepDefinitionIds = (_a = testStep.stepDefinitionIds) === null || _a === void 0 ? void 0 : _a.map((stepDefinitionId) => stepDefinitionId.replace(stepDefinition.id, seenDefinition.id));
                        }
                    }
                }
            }
            else {
                seenDefinitions.push({
                    id: stepDefinition.id,
                    uri: stepDefinition.sourceReference.uri,
                    line: stepDefinition.sourceReference.location.line,
                    column: stepDefinition.sourceReference.location.column,
                });
            }
        }
    }
}
